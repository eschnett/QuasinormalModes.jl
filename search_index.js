var documenterSearchIndex = {"docs":
[{"location":"sho/#Complete-Example:-The-Harmonic-Oscilator","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"We can use QuasinormalModes.jl to compute the eigenvalues of any 2nd order differential equation. To illustrate this we will show how to compute the energy eigenvalues of the quantum harmonic oscillator following Ref. [3].","category":"page"},{"location":"sho/#Mathematical-preliminaries","page":"Complete Example: The Harmonic Oscilator","title":"Mathematical preliminaries","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"If we measure the energy of the system in units of hbaromega and distance in units of sqrthbar(momega) the time independent Schrödinger equation for the system is written as","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"-psi^primeprime(x) + x^2psi(x) = epsilonpsi(x)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"where we defined epsilon equiv 2 E and E is the quantum state's energy. Imposing that psi(x) decays like a Gaussian distribution asymptotically, we apply the ansatz","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"psi(x) = e^-x^22f(x)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"which substituting in the original equation yeilds","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"f^primeprime(x) = 2 x f^prime(x) + (1-epsilon)f(x)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"This allows us to easily identify lambda_0 = 2x and s_0 = 1 - epsilon. In all our implementations we shall refer the sough eigenvalue epsilon using the variable ω in order to maintain consistency with the previous example.","category":"page"},{"location":"sho/#Implementing-Using-QuadFreqData","page":"Complete Example: The Harmonic Oscilator","title":"Implementing Using QuadFreqData","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"struct HarmonicOscilatorData <: QuadFreqData # Indicate that we will operate semi-analytically\n    nIter::UInt32                            # The number of iteration the AIM will perform\n    x0::Float64                              # The evaluation point for the AIM functions\n\n    vars::Tuple{Basic, Basic}                # The variables x and ω as SymEngine expressions.\n    exprs::Tuple{Basic, Basic}               # The functions λ0 and S0 as SymEngine expressions.\n    \n    function HarmonicOscilatorData(nIter::UInt32, x0::Float64 = 0.5)\n\t\n        vars = @vars x ω\n\t\n        λ0 = 2*x\n        S0 = 1 - ω\n\n        return new(nIter, x0, vars, (λ0, S0))\n    end\nend ","category":"page"},{"location":"sho/#Implementing-Using-GenFreqData","page":"Complete Example: The Harmonic Oscilator","title":"Implementing Using GenFreqData","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"struct NHarmonicOscilatorData <: GenFreqData # Indicate that we will operate semi-analytically\n    nIter::UInt32                            # The number of iteration the AIM will perform\n    x0::Float64                              # The evaluation point for the AIM functions\n    \n    function NHarmonicOscilatorData(nIter::UInt32, x0::Float64 = 0.0)\n        return new(nIter, x0)\n    end\nend \n\nfunction (data::NHarmonicOscilatorData)(idx::UInt32,\n                                        x::TaylorSeries.Taylor1{Complex{BigFloat}},\n                                        ω::Complex{BigFloat}\n                                        )::Array{Complex{BigFloat},1}\n    \n    if idx == 0x00001\n        ts = 2*x # The expression for λ0\n        return ts.coeffs\n    elseif idx == 0x00002\n        ts = 1 - ω + x - x # The expression for S0. We add and subtract x in order for the taylor expansion to work\n        return ts.coeffs\n    end\nend","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"note: Add and subtract `x`\nIn the expression for S0 we have added and subtracted the variable x. This is done because as S0 is independent of x the variable ts would be of type Complex{BigFloat} and the ts.coeffs instruction would fail. By adding and subtracting s we transform the expression for S0 in a TaylorSeries object that can be expanded correctly.","category":"page"},{"location":"sho/#Computing-the-modes","page":"Complete Example: The Harmonic Oscilator","title":"Computing the modes","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"To compute the modes we proceed exactly as in the previous Schwarzschild example. The eigenenergies of the harmonic oscillator are well know","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"epsilon_n = 2 n + 1","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"thus we will use custom printing routines to display only the real part of the computed energies and sort them by ascending order. In the semi-analytic case this can be done with","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"data = HarmonicOscilatorData(UInt32(50))\nmodes = computeQNMs(data, plr_epsilon=BigFloat(\"1.0e-20\"))\n\nsort!(modes, by = x -> real(x))\n    \nfor mode in modes\n    println(round(Int64,real(mode)))\nend\t","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"which will produce a list of the 50 first even numbers which corresponds to the expected result. We can also verify that the purely numeric case also produces correct results by computing a single energy with","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"data = NHarmonicOscilatorData(UInt32(50))\nmode = computeQNMs(data, Complex{BigFloat}(BigFloat(\"15.0\"), BigFloat(\"1.0\")), nls_xtol=BigFloat(\"1.0e-20\"), nls_ftol=BigFloat(\"1.0e-20\"))\n\nif mode.x_converged || mode.f_converged\n    println(mode.zero[1], \"    \", mode.zero[2])\nelse\n    println(\"Did not converge to any modes :-(\")\nend","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"or by sweeping the complex grid with","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"data = NHarmonicOscilatorData(UInt32(50))\n\ngrid_start = Complex{BigFloat}(BigFloat(\"1.0\"), BigFloat(\"-1.0\"))\ngrid_end = Complex{BigFloat}(BigFloat(\"20.0\"), BigFloat(\"-0.01\"))\n\nreal_pts = 5\nimag_pts = 5\n\ngrid = (grid_start, grid_end, real_pts, imag_pts)\nmodes = modesInGrid(data, grid, xtol=BigFloat(\"1.0e-20\"), ftol=BigFloat(\"1.0e-20\"))\nsort!(modes, by = x -> real(x))\n    \nfor mode in modes\n    println(round(Int64,real(mode)))\nend","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This package's primary objective is to compute qusinormal modes (QNMs) black holes in General Ralativity fast an accurately. QNMs are the characteristic oscillations produced by black holes when perturbed. These oscillations decay exponentially in time and thus it's said that QNMs contain a real omega_R oscillation frequency and an imaginary omega_I frequency that represents the mode's decay rate. For a comprehensive review see [1].","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To compute qusinormal frequencies this package uses the Asymptotic Iteration Method (AIM) [2], more specifically the \"improved\" version of the AIM as described in [3]. The AIM can be used to find the eigenvectors and eigenvalues of any second order differential equation (the class of problems with which the quasi normal modes belong) and thus this package can be used not only in the context of General Relativity but can also be used in to find the eigenvalues of any 2nd order ODE such as finding eigenenergies  of a quantum system described by the time independent Schrödinger equation.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In the following sections we will describe QuasinormalModes.jl API and how to use it in a series of (hopefully sufficient) examples so that new users can quickly set up their equations within the infrastructure and get results.","category":"page"},{"location":"intro/#Installing","page":"Introduction","title":"Installing","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This package can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"pkg> add QuasinormalModes","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and then type backspece to exit back to the REPL.","category":"page"},{"location":"intro/#Arbtrary-precision","page":"Introduction","title":"Arbtrary precision","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"By default, all of the computations performed by this package are carried out using arbitrary precision arithmetic. This is desirable since in root finding catastrophic numerical cancellations can occur if only floating point accuracy is used. To control the number of significant digits globally use Julia's setprecision and setrounding methods. We also recommend the reading of the Arbitrary Precision Arithmetic section of the official documentation.","category":"page"},{"location":"#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [\"intro.md\", \"schw.md\", \"sho.md\", \"api_ref.md\"]","category":"page"},{"location":"api_ref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Here we present the API reference for all functions and types within the module. The end user must only use the exported objects but private objects are also documented for completeness","category":"page"},{"location":"api_ref/#Public-types","page":"API Reference","title":"Public types","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"api_ref/#QuasinormalModes.AIMEvalPointException","page":"API Reference","title":"QuasinormalModes.AIMEvalPointException","text":"Exception that can be thrown by the user when the evaluation point of the QNM data is out of the allowed range.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.GenFreqData","page":"API Reference","title":"QuasinormalModes.GenFreqData","text":"Parent type of all space-times that have QNM equations that are generic functions of ω and x.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.QNMData","page":"API Reference","title":"QuasinormalModes.QNMData","text":"Parent type of all QNM data types.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.QuadFreqData","page":"API Reference","title":"QuasinormalModes.QuadFreqData","text":"Parent type of all space-times that have QNM equations that are quadratic in the frequency ω.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#Public-functions","page":"API Reference","title":"Public functions","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"api_ref/#QuasinormalModes.computeQNMs-Tuple{GenFreqData,Complex{BigFloat}}","page":"API Reference","title":"QuasinormalModes.computeQNMs","text":"computeQNMs(data::GenFreqData,\n            guess::Complex{BigFloat};\n\n            nls_xtol::BigFloat = BigFloat(\"1.0e-15\"),\n            nls_ftol::BigFloat = BigFloat(\"1.0e-15\"),\n            nls_iterations::Int64 = 1000\n            )\n\nCompute a single quasinormal mode from the previously created GenFreqData space-time data.\n\nInput\n\ndata::GenFreqData: The previously defined numeric space-time data.\nguess::Complex{BigFloat}: The initial guess used for computing the mode.\nnls_xtol::BigFloat: Norm difference in x between two successive iterates under which convergence is declared.\nnls_ftol::BigFloat: Infinite norm of residuals under which convergence is declared.\nnls_iterations::Int64: Maximum number of iterations performed by NLsolve.\n\nOutput\n\nAn object of type SolverResults returned by nlsolve. See NLsolve.jl\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeQNMs-Tuple{QuadFreqData}","page":"API Reference","title":"QuasinormalModes.computeQNMs","text":"computeQNMs(data::QuadFreqData;\n            plr_polish::Bool = true, \n            plr_epsilon::BigFloat = BigFloat(1.0e-20)\n            )\n\nCompute the quasinormal modes from the previouslly created QuadFreqData space-time data.\n\nInput\n\ndata::QuadFreqData: The previously defined space-time data. \nplr_polish::Bool: Tell PolynomialRoots to divide the original polynomial by each root found and polish the results using the full polynomial.\nplr_epsilon::BigFloat: The stopping criterion described in Skowron & Gould paper. This is not the precision with which the roots will be calculated.\n\nOutput\n\nAn object of type Array{Complex{BigFloat},1} containing the computed modes.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.filterQNMs!","page":"API Reference","title":"QuasinormalModes.filterQNMs!","text":"function filterQNMs!(qnms::Array{Complex{BigFloat}, 1},\n                     cutoff::BigFloat = BigFloat(1.0e-5),\n                     instab::Bool = false\n                     )\n\nFilter the array of quasinormal modes previously computed using computeQNMs in-place.\n\nInput\n\nqnms::Array{Complex{BigFloat}, 1}: Array of QNMs to be filtered.\ncutoff::BigFloat: All QNMs whose real parts are smaller than this value are excluded.\ninstab::Bool: If this flag is set to true, the output file will also contain instabilities (QNMs with positive imaginary part).\n\nOutput\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api_ref/#QuasinormalModes.modesInGrid-Tuple{GenFreqData,Tuple{Complex{BigFloat},Complex{BigFloat},Int64,Int64}}","page":"API Reference","title":"QuasinormalModes.modesInGrid","text":"function modesInGrid(data::GenFreqData,\n                     grid::Tuple{Complex{Float64},Complex{Float64},Int64,Int64};\n                     xtol::BigFloat = BigFloat(\"1.0e-15\"),\n                     ftol::BigFloat = BigFloat(\"1.0e-15\"),\n                     iterations::Int64 = 1000\n                     )::Array{Complex{BigFloat},1}\n\nAttempts to find QNMs using a grid of complex plane data points as initial guesses to nlsolve.\n\nInput\n\ndata::GenFreqData: The space-time data to use.\ngrid::Tuple{Complex{Float64},Complex{Float64},Int64,Int64}: A tuple consisting of (start point, end point, num. of real pts., num. of imag. pots.).\nxtol::BigFloat: Norm difference in x between two successive iterates under which convergence is declared.\nftol::BigFloat: Infinite norm of residuals under which convergence is declared.\niterations::Int64: Maximum number of iterations performed by NLsolve.\n\nOutput\n\nAn object of type Array{Complex{BigFloat},1} containing the modes found within the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.printQNMs-Tuple{Array{Complex{BigFloat},1}}","page":"API Reference","title":"QuasinormalModes.printQNMs","text":"function printQNMs(qnms::Array{Complex{BigFloat}, 1};\n                   cutoff::BigFloat = BigFloat(1.0e-5),\n                   instab::Bool = false\n                   )\n\nPrints the quasinormal modes previously computed using computeQNMs to stdout.\n\nInput\n\nqnms::Array{Complex{BigFloat}, 1}: Array of QNMs.\ncutoff::BigFloat: All QNMs whose real parts are smaller than this value are not printed.\ninstab::Bool: If this flag is set to true, the output file will also contain instabilities (QNMs with positive imaginary part).\n\nOutput\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.saveQNMs-Tuple{Array{Complex{BigFloat},1}}","page":"API Reference","title":"QuasinormalModes.saveQNMs","text":"saveQNMs(qnms::Array{Complex{BigFloat}, 1};\n         filename::String = \"qnms.dat\",\n         cutoff::BigFloat = BigFloat(1.0e-5),\n         instab::Bool = false\n         )\n\nSave the quasinormal modes previously computed using computeQNMs.\n\nInput\n\nqnms::Array{Complex{BigFloat}, 1}: Array of QNMs.\nfilename::String: The name of the file with the computed QNMs.\ncutoff::BigFloat: All QNMs whose real parts are smaller than this value are not saved in the output file.\ninstab::Bool: If this flag is set to true, the output file will also contain instabilities (QNMs with positive imaginary part).\n\nOutput\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#Private-types","page":"API Reference","title":"Private types","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPublic = false\nOrder   = [:type]","category":"page"},{"location":"api_ref/#QuasinormalModes.InvalidGridException","page":"API Reference","title":"QuasinormalModes.InvalidGridException","text":"Exception that is thrown when the grid passed to modesInGrid is not properly formatted\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#Private-functions","page":"API Reference","title":"Private functions","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPublic = false\nOrder   = [:function]","category":"page"},{"location":"api_ref/#QuasinormalModes.AIMStep!-Tuple{QNMData,Any,Any,Any,Any,Any,Any,Any,Any}","page":"API Reference","title":"QuasinormalModes.AIMStep!","text":"function AIMStep!(data::QNMData, icda, ccda, pcda, bcda, idda, cdda, pdda, bdda)\n\nPerforms a single step of the AIM algorithm:\n\nThe initial data arrays are not altered.\nThe previous arrays receive the values of the current arrays.\nThe results of the next step computed using the initial and current arrays. Results are stored in the buffer arrays.\nThe current arrays receive the contents of the buffer arrays.\n\nInput\n\ndata::QNMData: The spacetime data to use in the computation.\nicda: Initial c data array.\nccda: Current c data array.\npcda: Previous c data array.\nbcda: Buffer c data array.\nidda: Initial d data array.\ncdda: Current d data array.\npdda: Previous d data array.\nbdda: Buffer d data array.\n\nOutput\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeDelta-Tuple{GenFreqData,Complex{BigFloat}}","page":"API Reference","title":"QuasinormalModes.computeDelta","text":"computeDelta(data::GenFreqData, ω::Complex{BigFloat})\n\nCompute and return the AIM \"quantization condition\".\n\nInput\n\ndata::GenFreqData: A generic frequency space-time data structure.\nω::Complex{BigFloat}: The value of ω at which the quantization condition is to be evaluated.\n\nOutput\n\nAn object of type Complex{BigFloat} that is zero if ω is a quasinormal mode.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeDelta-Tuple{QuadFreqData}","page":"API Reference","title":"QuasinormalModes.computeDelta","text":"computeDelta(data::QuadFreqData)\n\nCompute and return the AIM \"quantization condition\".\n\nInput\n\ndata::QuadFreqData: A quadratic frequency space-time data structure.\n\nOutput\n\nAn object of type Polynomial{Complex{BigFloat}} whose roots are the quasinormal modes.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.createPoly-Tuple{QuadFreqData,UInt32,UInt32}","page":"API Reference","title":"QuasinormalModes.createPoly","text":"createPoly(data::QuadFreqData, n::UInt32, idx::UInt32)::Polynomial{Complex{BigFloat}}\n\nCreate a 2nd order Polynomial object in the variable ω by computing derivatives of λ0 or S0.\n\nInput\n\ndata::QuadFreqData: The spacetime data with the expressions to derivate.\nn::UInt32: The order of the derivative.\nidx::UInt32: The actual expression to derivate. If idx = 0x00001 it computes a derivative of λ0. If idx = 0x00002 it computes a derivative iof S0.\n\nOutput\n\nAn object of type Polynomial{Complex{BigFloat}} containing the polynomial resulting from the derivation of the expression.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.dnx-Tuple{QuadFreqData,UInt32,UInt32}","page":"API Reference","title":"QuasinormalModes.dnx","text":"function dnx(data::QuadFreqData, n::UInt32, idx::UInt32)\n\nComputes n-th derivative of the AIM expressions with respect to ODE's variable, usually called x.\n\nInput\n\ndata::QuadFreqData: The spacetime data with the expressions to derivate.\nn::UInt32: The order of the derivative.\nidx::UInt32: The actual expression to derivate. If idx = 0x00001 it computes a derivative of λ0. If idx = 0x00002 it computes a derivative of S0.\n\nOutput\n\nA SymEngine.Basic object with the derived expression.\n\n\n\n\n\n","category":"method"},{"location":"schw/#Complete-Example:-Schwarzschild-Quasinormal-Modes","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"To illustrate how to use QuasinormalModes.jl we will show from start to finish how to compute the quasinormal modes of a Schwarzschild black hole perturbed by a field. This section will follow closely Emanuele Berti's lectures on black hole perturbation theory, which can be found here and in Ref. [3]","category":"page"},{"location":"schw/#Mathematical-preliminaries","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Mathematical preliminaries","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Let's say that our Schwarzschild black hole is being perturbed by an external field psi_ls where s is the spin of the field (s = 0 1 2 for scalar, electromagnetic and gravitational perturbations, respectively) and l is the angular index of the perturbation. Using mass units such that 2M=1 the \"master\" radial equation governing the perturbation is ","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"r(r-1)psi_ls^primeprime(r) + psi_ls^prime(r) - left l(l+1) - fracs^2-1r - fracomega^2 r^3r-1 rightpsi_ls(r) = 0","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"where primes denote derivatives with respect to the radial coordinate r and omega are the quasinormal frequencies. Since we are solving for quasinormal modes, we need to enforce the proper boundary conditions in the master equation: Classically no wave can escape from the BH's event horizon and at spatial infinity waves can only \"leave\" the space-time. It's thus said that our field is purely ingoing in the event horizon (when rrightarrow 1) and purely outgoing at spatial infinity (when rrightarrowinfty). Mathematically, this means that the solution to the master equation must be of the form","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"psi_ls(r) = (r-1)^-i omega r^2 i omega e^i omega (r-1)f_ls(r)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"By substituting this solution ansatz in the master equation, we obtain a new 2nd order ODE, now for the function f_ls(r). This new ODE is enforcing the correct boundary quasinormal mode boundary conditions. This process usually referred to as incorporating the boundary conditions into the differential equation. The resulting equation reads","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"r left((r-1) r f^primeprime(r)+left(1+2 i left(r^2-2right) omega right) f^prime(r)right)+f(r) left(-r left(l^2+l-4 omega ^2right)+s^2+(2 omega +i)^2right) = 0","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The last step, although not strictly required, facilitates the numerical handling of the equation. Because the radial coordinates extends from the event horizon to infinity, that is, rin 1infty and computers can't handle infinities, we re-scale the ODE's domain to a finite one. This can be easily done with the change of variables","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"x = 1 - frac1r","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"which implies that when r=1 we have x=0 and when rrightarrowinfty we have x = 1. Thus the solution domain has been successfully compactifyied in the interval xin01. By making this change of variables we get to the final form of the master equation which we will actually feed to QuasinormalModes.jl","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"-x (x-1)^2 f^primeprime(x) + (x (4 i (x-2) omega -3 x+4)+2 i omega -1) f^prime(x)+f(x) left(l^2+l+left(s^2-1right) (x-1)+4 (x-2) omega ^2+4 i (x-1) omega right) = 0","category":"page"},{"location":"schw/#Implementing-the-master-equation","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Implementing the master equation","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"QuasinormalModes.jl uses Julia's type system to implement structures that can used to solve the eigenvalue problem via the AIM. All ODEs are implemented as structures that are subtypes of one of the following abstract types. Each abstract type listed bellow is a subtype of the parent type QNMData:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"QuadFreqData - Aimed at ODEs in which the eigenvalue is a quadratic polynomial.\nGenFreqData - Aimed at ODEs in which the eigenvalue a general function.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"With structures that are a subtype of QuadFreqData, QuasinormalModes.jl takes advantage of the polynomial nature of the eigenvalues in the ODE and operates in a semi-analytic way. Modes are computed by finding roots of the large polynomials in the eigenvalue produced by the iteration steps of the AIM using PolynomialRoots.jl. Since all roots are found, this approach can generate extensive lists of quasinormal modes without the need of an initial \"guess\".","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"With structures that are a subtype of GenFreqData, QuasinormalModes.jl makes no assumptions about the eigenvalue and operates in a purely numeric way. In fact, the ODE might even contain numeric functions of the eigenvalue. Since it's hard to determine all the roots and poles of generic complex functions, when operating in this mode QuasinormalModes.jl requires in initial \"guess\" to be given for root finding which is carried out by NLsolve.jl.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"note: Semi-analytic VS numeric approach\nBecause of the semi-analytic nature of the operation performed when a structure is a subtype of QuadFreqData, QuasinormalModes.jl is naturally slower to compute modes in this case. One may also find that for a large number of iterations the AIM might even fail to find modes. A general good approach would be to use the semi-analytic mode to generate lists of eigenvalues for a number of iterations that runs reasonably fast and then use these results as initial guesses for the numeric mode with a high number of iterations. ","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The AIM can be used to solve generic 2nd order ODES of the form","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"y^primeprime(x) = lambda_0(x)y^prime(x) + s_0(x)y(x)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The structures we construct must contain the lambda_0(x) and s_0(x) functions, which we will derive from or master equation. If we are sub-typing QuadFreqData we must implement these functions as well as x and omega as symbolic variables and include SymEngine.jl as a dependency. If we are sub-typing GenFreqData we must include TaylorSeries.jl in the project as this package is responsible for computing the high order derivatives necessary to the AIM.","category":"page"},{"location":"schw/#Using-QuadFreqData","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Using QuadFreqData","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Here is how to implement the Schwarzchild master equation we derived previously taking advantage of the fact that omega is a quadratic polynomial","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"struct SchwarzschildData <: QuadFreqData # Indicate that we will operate semi-analytically\n    nIter::UInt32                        # The number of iteration the AIM will perform\n    x0::Float64                          # The evaluation point for the AIM functions\n\n    l::UInt32                            # The angualar number.\n    s::UInt32                            # The perturbation spin.\n    vars::Tuple{Basic, Basic}            # The variables x and ω as SymEngine expressions.\n    exprs::Tuple{Basic, Basic}           # The functions λ0 and S0 as SymEngine expressions.\n    \n    function SchwarzschildData(nIter::UInt32, l::UInt32, s::UInt32, x0::Float64 = 0.5)\n\t\n        # Make sure that teh evaluation point is inside the ODE interval.\n        # The ODE is singular at the endpoints so they are not allowed.\n        if x0 >= 1.0 || x0 <= 0.0\n            error(\"x0 must be a number in the open interval 0 < x < 1.\")\n            throw(AIMEvalPointException)\n        end\n\n        vars = @vars x ω\n\t\n        λ0 = (-1 + (2*im)*ω + x*(4 - 3*x + (4*im)*(-2 + x)*ω))/((-1 + x)^2*x)\n        S0 = (l + l^2 + (-1 + s^2)*(-1 + x) + (4*im)*(-1 + x)*ω + 4*(-2 + x)*ω^2)/((-1 + x)^2*x)\n\n        return new(nIter, x0, l, s, vars, (λ0, S0))\n    end\nend","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Any structure that subtypes QuadFreqData must contain the following fields:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"nIter::UInt32\nx0::Float64\nvars::Tuple{Basic, Basic}\nexprs::Tuple{Basic, Basic}","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"This is because QuasinormalModes.jl internally expects all concrete types that are sub-types of QuadFreqData to have these fields in order to function correctly. We recommend that users use the above example as a template to implement their own space-times.","category":"page"},{"location":"schw/#Using-GenFreqData","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Using GenFreqData","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Here is how to implement the Schwarzchild master equation we derived previously in a purely numeric way","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"struct NSchwarzschildData <: GenFreqData # Indicate that we will operate semi-analytically\n    nIter::UInt32                        # The number of iteration the AIM will perform\n    x0::Float64                          # The evaluation point for the AIM functions\n\n    l::UInt32                            # The angualar number.\n    s::UInt32                            # The perturbation spin.\n    \n    function NSchwarzschildData(nIter::UInt32, l::UInt32, s::UInt32, x0::Float64 = 0.5)\n        \n        # Make sure that teh evaluation point is inside the ODE interval.\n        # The ODE is singular at the endpoints so they are not allowed.\n        if x0 >= 1.0 || x0 <= 0.0\n            error(\"x0 must be a number in the open interval 0 < x < 1.\")\n            throw(AIMEvalPointException)\n        end\n\n        return new(nIter, x0, l, s)\n    end\nend \n\nfunction (data::NSchwarzschildData)(idx::UInt32,\n                                    x::TaylorSeries.Taylor1{Complex{BigFloat}},\n                                    ω::Complex{BigFloat}\n                                    )::Array{Complex{BigFloat},1}\n    \n    if idx == 0x00001\n        ts = (-1 + (2*im)*ω + x*(4 - 3*x + (4*im)*(-2 + x)*ω))/((-1 + x)^2*x) # The expression for λ0\n        return ts.coeffs\n    elseif idx == 0x00002\n        ts =(data.l + data.l^2 + (-1 + data.s^2)*(-1 + x) + (4*im)*(-1 + x)*ω + 4*(-2 + x)*ω^2)/((-1 + x)^2*x) # The expression for S0\n        return ts.coeffs\n    end\nend","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Any structure that subtypes GenFreqData must contain the following fields:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"nIter::UInt32\nx0::Float64","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Additionally the operator () must be overloaded to work with the newly defined type and it's signature must be exactly that of the example. In the expressions for λ0 and S0 the space-time specific parameters l and s have been replaced by data.l and data.s so that they can be located during runtime. Again we recommend that users use the above example as a template to implement their own space-times.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"note: This is too much code!\nAt this point the user might be scared with the amount of boilerplate code required to implement a spacetime so that QuasinormalMods.jl can do it's job. The authors are well aware of this fact and intend to improve the package so that it eventually becomes easier to implement these structures with the correct signatures. In the meantime, we recommend that the user uses the provided .jl example files as starting points to their projects. In the following section we will show how to use these structures to compute QNMs. Rest assured that once the structures are constructed, computing the modes is much easier.","category":"page"},{"location":"schw/#Computing-the-modes","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Computing the modes","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"In order to compute the modes it is only necessary to invoke the function computeQNMs with the space-time structure and in the case of a structure that sub-types GenFreqData the initial guess as a second argument.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"For example, if our structure is a syb-type of QuadFreqData we would do","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"data = SchwarzschildData(UInt32(50), UInt32(0), UInt32(0))\nmodes = computeQNMs(data, plr_epsilon=BigFloat(\"1.0e-20\"))","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"and modes would be an object of type Array{Complex{BigFloat},1} containing the computed modes with 20 iterations of the AIM.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"If our structure is a syb-type of GenFreqData we would do","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"data = NSchwarzschildData(UInt32(50), UInt32(0), UInt32(0))\nmode = computeQNMs(data, Complex{BigFloat}( BigFloat(\"0.220\"), BigFloat(\"-0.209\")))","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"and mode would be an object of type SolverResults returned by NLsolve. We encourage the reader to read NLsolve's documentation, but what users usually will want to know is if the solver converged to a mode and the actual value of the mode. Convergence can be tested with","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"converged = mode.x_converged || mode.f_converged","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"and the real and imaginary part of the solution are obtained with","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"real_part = mode.zero[1]\nimag_part = mode.zero[2]","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"We chose to return NLsolve's solution object instead of a more \"neatly\" formatted complex number to allow the users more freedom in their applications.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Aside from computeQNMs, if our space-time structure is a sub-type of GenFreqData, we can explore the existence of modes inside a grid of points in the complex plane. This is accomplished by the function modesInGrid In code we wold do","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"data = NSchwarzschildData(UInt32(50), UInt32(0), UInt32(0))\n\ngrid_start = Complex{BigFloat}(BigFloat(\"0.01\"), BigFloat(\"-1.0\"))\ngrid_end = Complex{BigFloat}(BigFloat(\"1.0\"), BigFloat(\"-0.01\"))\n\nreal_pts = 5\nimag_pts = 5\n\ngrid = (grid_start, grid_end, real_pts, imag_pts)\n\nmodes = modesInGrid(data, grid)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The variable modes would be an array of type Array{Complex{BigFloat},1} containing the modes found in the grid. We specify a grid by start and end points in the complex plane and choosing how many points to compute in the real an imaginary part of the grid. In the example we will try to find modes for 25 (5x5) initial conditions inside the chosen rectangle in the complex plane. We might see that some modes repeat inside the modes array. this is of course to be expected as multiple initial conditions will lead NLsolve to converge to a certain mode.","category":"page"},{"location":"schw/#Printing-the-modes","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Printing the modes","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Having computed a single mode or an array of modes we can easily operate on these results in any way we want. For convenience we provide functions to save print and filter modes. To save modes (an object of type Array{Complex{BigFloat},1} under the name \"qnms.dat\" we would simply do","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"saveQNMs(modes, filename = \"qnms.dat\")","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"There are also arguments controlling the cutoff of the real part of the modes (the value from which modes are no longer saved in the output file) and whether to save instabilities (modes with positive imaginary part).","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The function printQNMs has the exact same signature as saveQNMs but instead of outputting to a file it writes the modes to stdout. Finally the function filterQNMs! has also the same signature and filters an array of QNMs in-place according to the cutoff and instab parameters.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"note: Complete code\nThe complete code of this example can be found under TODOl: LINK TO EXAMPLE FILE","category":"page"}]
}
