var documenterSearchIndex = {"docs":
[{"location":"sho/#Complete-Example:-The-Harmonic-Oscilator","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"We will now turn away from general relativity and use QuasinormalModes.jl to compute to compute the energy eigenvalues of the quantum harmonic oscillator following this paper.","category":"page"},{"location":"sho/#Mathematical-preliminaries","page":"Complete Example: The Harmonic Oscilator","title":"Mathematical preliminaries","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"If we measure the energy of the system in units of hbaromega and distance in units of sqrthbar(momega) the time independent Schrödinger equation for the quantum harmonic oscilator is written as","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"-psi^primeprime(x) + x^2psi(x) = epsilonpsi(x)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"where we defined epsilon equiv 2 E and E is the quantum state's energy. Imposing that psi(x) decays like a Gaussian distribution asymptotically, we apply the ansatz","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"psi(x) = e^-x^22f(x)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"which substituting in the original equation yields","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"f^primeprime(x) = 2 x f^prime(x) + (1-epsilon)f(x)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"This allows us to easily identify lambda_0 = 2x and s_0 = 1 - epsilon. In all our implementations we shall refer the sought eigenvalue epsilon using the variable ω in order to maintain consistency with the previous example.","category":"page"},{"location":"sho/#Implementing-the-master-equation-as-an-analytic-problem","page":"Complete Example: The Harmonic Oscilator","title":"Implementing the master equation as an analytic problem","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"In this section we will assume that the user has installed and loaded the SymEngine package. The first step is to create a parametric type that sub-types AnalyticAIMProblem. As the eigenvalue in the master equation is a quadratic polynomial, we will sub-type QuadraticEigenvalueProblem with the following structure:","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"struct HarmonicOscilatorData{N,T} <: QuadraticEigenvalueProblem{N,T}\n    nIter::N\n    x0::T\n\n    vars::Tuple{Basic, Basic}\n    exprs::Tuple{Basic, Basic}\nend","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"Following our previous example, we implement the constructor and extend the default implementations:","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"function HarmonicOscilatorData(nIter::N, x0::T) where {N,T}\n\t\n    vars = @vars x ω\n\n    λ0 = 2*x\n    S0 = 1 - ω\n\n    return HarmonicOscilatorData{N,T}(nIter, x0, vars, (λ0, S0))\nend\n\nQuasinormalModes.λ0(d::HarmonicOscilatorData{N,T}) where {N,T} = d.exprs[1]\nQuasinormalModes.S0(d::HarmonicOscilatorData{N,T}) where {N,T}  = d.exprs[2]\n\nQuasinormalModes.get_niter(d::HarmonicOscilatorData{N,T}) where {N,T} = d.nIter\nQuasinormalModes.get_x0(d::HarmonicOscilatorData{N,T}) where {N,T} = d.x0\n\nQuasinormalModes.get_ODEvar(d::HarmonicOscilatorData{N,T}) where {N,T} = d.vars[1]\nQuasinormalModes.get_ODEeigen(d::HarmonicOscilatorData{N,T}) where {N,T} = d.vars[2]","category":"page"},{"location":"sho/#Implementing-the-master-equation-as-a-numeric-problem","page":"Complete Example: The Harmonic Oscilator","title":"Implementing the master equation as a numeric problem","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"The structure, constructor and extensions are","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"struct NHarmonicOscilatorData{N,T} <: NumericAIMProblem{N,T}\n    nIter::N\n    x0::T\nend\n\nfunction NHarmonicOscilatorData(nIter::N, x0::T) where {N,T}\n    return NHarmonicOscilatorData{N,T}(nIter, x0)\nend\n\nQuasinormalModes.λ0(::NHarmonicOscilatorData{N,T}) where {N,T} = (x,ω) -> 2*x\nQuasinormalModes.S0(::NHarmonicOscilatorData{N,T}) where {N,T} = (x,ω) -> 1 - ω + x - x\n\nQuasinormalModes.get_niter(d::NHarmonicOscilatorData{N,T}) where {N,T} = d.nIter\nQuasinormalModes.get_x0(d::NHarmonicOscilatorData{N,T}) where {N,T} = d.x0","category":"page"},{"location":"sho/#Constructing-problems-and-initializing-the-cache","page":"Complete Example: The Harmonic Oscilator","title":"Constructing problems and initializing the cache","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"Once again, we create our problems and cache objects by calling the constructors:","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"p_ana = HarmonicOscilatorData(0x0000A, 0.5);\np_num = NHarmonicOscilatorData(0x0000A, 0.5);\n\nc_ana = AIMCache(p_ana)\nc_num = AIMCache(p_num)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"Here we are setting up problems to be solved using 10 iterations with x0 = 0.5","category":"page"},{"location":"sho/#Computing-the-eigenvalues","page":"Complete Example: The Harmonic Oscilator","title":"Computing the eigenvalues","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"Once again we compute the eigenvalues by calling","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"ev_ana = computeEigenvalues(p_ana, c_ana)\nev_num = eigenvaluesInGrid(p_num, c_num, (0.0, 21.0))","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"The results are two arrays, containing the eigenvalues. As before, we define a function to print the results to stdout","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"function printEigen(eigenvalues)\n    println(\"--------------------------------------\")\n\n    for i in eachindex(eigenvalues)\n        println(\"n = $i, ω = $(eigenvalues[i])\")\n    end\n    \n    println(\"--------------------------------------\")\n\n    return nothing\nend\n\nprintln(\"Analytic results\")\nprintEigen(reverse!(ev_ana))\n\nprintln(\"Numeric results\")\nprintEigen(ev_num)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"The complete source file for this example can be found in harmonic_oscilator.jl. The output is agreement with the expected result for the eigenenergies of the harmonic oscillator, that is, E_n = n + 12","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscilator","title":"Complete Example: The Harmonic Oscilator","text":"Analytic results\n--------------------------------------\nn = 1, ω = 0.9999999999999999 + 0.0im\nn = 2, ω = 2.9999999999999964 + 0.0im\nn = 3, ω = 4.999999999999426 + 0.0im\nn = 4, ω = 7.000000000006788 + 0.0im\nn = 5, ω = 8.999999999980533 + 0.0im\nn = 6, ω = 10.999999804542819 + 0.0im\nn = 7, ω = 13.000000959453153 + 0.0im\nn = 8, ω = 14.999998108295404 + 0.0im\nn = 9, ω = 17.00000187312756 + 0.0im\nn = 10, ω = 18.999999068409203 - 0.0im\nn = 11, ω = 21.000000186185098 + 0.0im\n--------------------------------------\nNumeric results\n--------------------------------------\nn = 1, ω = 1.0\nn = 2, ω = 3.000000000000006\nn = 3, ω = 5.000000000000002\nn = 4, ω = 7.000000000000006\nn = 5, ω = 8.999999999999988\nn = 6, ω = 11.0\nn = 7, ω = 12.999999999999977\nn = 8, ω = 15.000000000000014\nn = 9, ω = 16.999999999999908\nn = 10, ω = 19.000000000000025\nn = 11, ω = 21.0\n--------------------------------------","category":"page"},{"location":"org/#Package-organization","page":"Package organization","title":"Package organization","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"QuasinormalModes.jl employs two main strategies in order to find eigenvalues using the AIM: problems can be solved in a semi-analytic or purely numeric fashion. We make use of Julia's type system in order to implement structures that reflect these operation modes. All of the package's exported functionality is designed to operate on sub-types of abstract types that reflect the desired solution strategy (semi-analytic or numeric). The user is responsible for constructing concrete types that are sub-types of the exported abstract types with the actual problem specific information. It's thus usefully to start by inspecting the package's exported type hierarchy:","category":"page"},{"location":"org/#The-type-hierarchy","page":"Package organization","title":"The type hierarchy","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"<table border=\"0\"><tr>\n<td>\n\t<figure>\n\t\t<img src='../assets/types.svg' alt='missing'><br>\n\t\t<figcaption><em>QuasinormalModes.jl type hierarchy</em></figcaption>\n\t</figure>\n</td>\n</tr></table>","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"AIMProblem is the parent type of all problems that can be solved with this package. All problems must be sub-type it and a user can use it to construct functions that operate on all AIM solvable problems.\nAnalyticAIMProlem is the parent type of all problems that can be solved using a semi-analytic approach.\nNumericAIMProblem is the parent type of all problems that can be solved using a numeric approach.\nQuadraticEigenvaluePoblem is a specific type of analytic problem whose eigenvalues appear in the ODE as a (possibly incomplete) quadratic polynomial.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"All types are parameterized by two parameters: N <: Unsigned and T <: Number which represent respectively, the type used to represent the number of iterations the AIM will perform and the type used in the numeric computations of the method.","category":"page"},{"location":"org/#Type-traits","page":"Package organization","title":"Type traits","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"Type traits are non-exported abstract types that help the user to ensure that their sub-types implement the correct functions. Currently there is only one defined trait, called AnalyticityTrait. This trait can have two possible \"values\": IsAnalytic and IsNumeric, that are represented by concrete types. The default trait of an AIMProblem is IsNumeric, while any sub-type of AnalyticAIMProblem has the IsAnalytic and NumericAIMProblem have the IsNumeric trait","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"With these traits, we enforce that the user must implement for all problem types, the following functions:","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"λ0: Return the λ0 component of the ODE. The actual implementation depends heavily on the problem type.\nS0: Return the S0 component of the ODE. The actual implementation depends heavily on the problem type.\nget_niter: Return the number of iterations that the AIM will perform.\nget_x0: Return the expansion point of the AIM.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"For problems with the IsAnalytic trait, the user must implement the following functions function:","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"get_ODEvar which returns an object that represents the ODE's variable.\nget_ODEeigen which returns an object that represents the ODE's eigenvalue.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"Failure to implement these functions returns an error with the appropriate message. Note that these traits only check that such functions are implemented for a certain problem type and not that they follow a particular implementation pattern. The contract on the functions implementations is soft and will be clarified further on. Failure to abide by these soft contracts results in undefined behaviour.","category":"page"},{"location":"org/#Extending-the-default-functionality","page":"Package organization","title":"Extending the default functionality","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"The following assumes that the package SymEngine is installed. If a problem type P{N,T} is a sub-type of AnalyticAIMProblem{N,T}, the user must extend the default implementations abiding by the following rules","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"QuasinormalModes.λ0(p::P{N,T}) where {N,T} must return a SymEngine.Basic objects representing the symbolic expression for the λ0 part of the ODE.\nQuasinormalModes.S0(p::P{N,T}) where {N,T} must return a SymEngine.Basic objects representing the symbolic expression for the S0 part of the ODE.\nQuasinormalModes.get_ODEvar(p::P{N,T}) where {N,T} must return a SymEngine.Basic objects representing the SymEngine variable associated with the ODE's variable.\nQuasinormalModes.get_ODEeigen(p::P{N,T}) where {N,T} must return a SymEngine.Basic objects representing the SymEngine variable associated with the ODE's eigenvalue.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"If a problem type P{N,T} is a sub-type of NumericAIMProblem{N,T}, the user must extend the default implementations abiding by the following rules","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"QuasinormalModes.λ0(p::P{N,T}) where {N,T} must return a lambda function of two parameters, the first representing the ODE's variable and the second representing the ODE's eigenvalue where the body represents the expression for the λ0 part of the ODE.\nQuasinormalModes.S0(p::P{N,T}) where {N,T} must return a lambda function of two parameters, the first representing the ODE's variable and the second representing the ODE's eigenvalue where the body represents the expression for the S0 part of the ODE.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"All problems P{N,T} that are a sub-type of AIMProblem{N,T} must extend the default implementations abiding by the following rules","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"QuasinormalModes.get_niter(p::P{N,T}) where {N,T} must return an unsigned number of type N representing the number of iterations for the AIM to perform.\nQuasinormalModes.get_x0(p::P{N,T}) where {N,T} must return a number of type T representing the evaluation point of the AIM.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"In the following sections, concrete examples of problems will be illustrated in order to better acquaint the user with the package and hopefully clear out any remaining misunderstandings.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"note: Semi-analytic VS numeric approach\nBecause of the semi-analytic nature of the operation performed when a structure is a subtype of AnalyticAIMProblem, QuasinormalModes.jl is naturally slower to compute modes in this case. One may also find that for a large number of iterations the AIM might even fail to find modes. A general good approach would be to use the semi-analytic mode to generate lists of eigenvalues for a number of iterations that runs reasonably fast and then use these results as initial guesses for the numeric mode with a high number of iterations.","category":"page"},{"location":"org/#The-memory-cache","page":"Package organization","title":"The memory cache","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"In order to minimize memory allocations, all functions that actually compute eigenvalues require a AIMCache object. Given a certain a problem P{N,T} it initializes memory for 8 arrays of size get_niter(p) + one(N) elements of type T. These arrays are used to store intermediate and final computation results. By using a cache object, we guarantee that memory for the computation data is allocated only once and not at each step of the AIM.","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This package's primary objective is to compute the discrete eigenvalues of second order ordinary differential equations. It was written with the intent to be used for computing qusinormal modes (QNMs) of black holes in General Relativity efficiently and accurately. QNMs are the discrete spectrum of characteristic oscillations produced by black holes when perturbed. These oscillations decay exponentially in time and thus it's said that QNMs contain a real omega_R oscillation frequency and an imaginary omega_I frequency that represents the mode's decay rate. These frequencies are often described by a discrete eigenvalue in a second order ODE. For a comprehensive review see [1].","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To compute eigenvalues (and thus qusinormal frequencies) this package uses the Asymptotic Iteration Method (AIM) [2], more specifically the \"improved\" version of the AIM as described in [3]. The AIM can be used to find the eigenvectors and eigenvalues of any second order differential equation (the class of problems with which the quasi normal modes belong) and thus this package can be used not only in the context of General Relativity but can also be used to find the discrete eigenvalues of other systems such as the eigenenergies of a quantum system described by the time independent Schrödinger equation.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In the following sections you will find the QuasinormalModes.jl API and instructions on how to use it in a series of (hopefully sufficient) examples.","category":"page"},{"location":"intro/#Installing","page":"Introduction","title":"Installing","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This package can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"pkg> add QuasinormalModes","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and then type backspace to exit back to the REPL.","category":"page"},{"location":"#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [\"intro.md\", \"schw.md\", \"sho.md\", \"api_ref.md\"]","category":"page"},{"location":"api_ref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Here we present the API reference for all functions and types within the module. The end user must only use the exported objects but private objects are also documented for completeness","category":"page"},{"location":"api_ref/#Pulblic-Modules","page":"API Reference","title":"Pulblic Modules","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPrivate = false\nOrder   = [:module]","category":"page"},{"location":"api_ref/#QuasinormalModes.QuasinormalModes","page":"API Reference","title":"QuasinormalModes.QuasinormalModes","text":"This package contains routines for computing eigenvalues of second order ordinary differential equations and in particular the qusinormal modes (QNMs) of black holes in General Relativity using the \"Asymptotic Iteration Method\" [1] using the implementation based on the \"improved\" version of the AIM, described in [2].\n\nReferences:\n\n1 2\n\n\n\n\n\n","category":"module"},{"location":"api_ref/#Public-types","page":"API Reference","title":"Public types","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"api_ref/#QuasinormalModes.AIMCache","page":"API Reference","title":"QuasinormalModes.AIMCache","text":"Cache of coefficient arrays for the AIM. To each AIM problem corresponds a cache. As long as the problem doesn't change, the cache can be reused.\n\nMembers\n\nicda::Array{T,1}: Hold the initial c data, i.e., c^i_0.\nccda::Array{T,1}: Hold the coefficients for the current aim step, c^i_n.\npcda::Array{T,1}: Hold the coefficients for the previous aim step, c^i_{n-1}.\nbcda::Array{T,1}: The work buffer used to actually compute the c coefficients in parallel.\nidda::Array{T,1}: Hold the initial d data, i.e., c^i_0.\ncdda::Array{T,1}: Hold the coefficients for the current aim step, d^i_n.\npdda::Array{T,1}: Hold the coefficients for the previous aim step, d^i_{n-1}.\nbdda::Array{T,1}: The work buffer used to actually compute the d coefficients in parallel.\nsize::N: The size of the arrays in the cache.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.AIMCache-Union{Tuple{NumericAIMProblem{N,T}}, Tuple{T}, Tuple{N}} where T<:Number where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.AIMCache","text":"AIMCache(p::NumericAIMProblem{N,T}) where {N <: Unsigned, T <: Number}\n\nCreate an AIMCache object suitable for Numeric Eigenvalue Problems.\n\nInput\n\np::NumericAIMProblem: The problem data.\n\nOutput\n\nAn AIMCache{N,T} object.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.AIMCache-Union{Tuple{QuadraticEigenvalueProblem{N,T}}, Tuple{T}, Tuple{N}} where T<:Number where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.AIMCache","text":"AIMCache(p::QuadraticEigenvalueProblem{N,T}) where {N <: Unsigned, T <: Number}\n\nCreate an AIMCache object suitable for Quadratic Eigenvalue Problems.\n\nInput\n\np::QuadraticEigenvalueProblem: The problem data.\n\nOutput\n\nAn AIMCache{N,Polynomial{T}} object.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.AIMProblem","page":"API Reference","title":"QuasinormalModes.AIMProblem","text":"Parent super-type of all problems that can be solved using the AIM.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.AnalyticAIMProblem","page":"API Reference","title":"QuasinormalModes.AnalyticAIMProblem","text":"Parent super-type of all problems that can be solved using the AIM semi-analytically.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.NumericAIMProblem","page":"API Reference","title":"QuasinormalModes.NumericAIMProblem","text":"Parent super-type of all problems that can be solved using the AIM numerically.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.QuadraticEigenvalueProblem","page":"API Reference","title":"QuasinormalModes.QuadraticEigenvalueProblem","text":"Parent super-type of all problems whose eigenvalue is a quadratic polynomial.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#Public-functions","page":"API Reference","title":"Public functions","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"api_ref/#QuasinormalModes.S0-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.S0","text":"All problem types must implement a S0 function. This behaviour is enforced by the default implementations.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeDelta!-Union{Tuple{T}, Tuple{N}, Tuple{NumericAIMProblem{N,T},AIMCache{N,T},T}} where T<:Number where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.computeDelta!","text":"computeDelta!(p::NumericAIMProblem{N,T}, c::AIMCache{N,T}, ω::T) where {N <: Unsigned, T <: Number}\n\nCompute and return the AIM \"quantization condition\".\n\nInput\n\np::QuadraticEigenvalueProblem: A quadratic frequency problem.\nc::AIMCache: An AIM cache object created from p.\nω::T: Point to evaluate the quantization condition.\n\nOutput\n\nAn object of type T which represents the AIM quantization condition at point ω.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeDelta!-Union{Tuple{T}, Tuple{N}, Tuple{QuadraticEigenvalueProblem{N,T},AIMCache{N,Polynomials.Polynomial{T}}}} where T<:Number where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.computeDelta!","text":"computeDelta!(p::QuadraticEigenvalueProblem{N,T}, c::AIMCache{N,Polynomial{T}}) where {N <: Unsigned, T <: Number}\n\nCompute and return the AIM \"quantization condition\".\n\nInput\n\np::QuadraticEigenvalueProblem: A quadratic frequency problem.\nc::AIMCache: An AIM cache object created from p.\n\nOutput\n\nAn object of type Polynomial{T} whose roots are the the problem's eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{NumericAIMProblem{N,T},AIMCache{N,T},T}} where T<:Complex where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.computeEigenvalues","text":"computeEigenvalues(\n    p::NumericAIMProblem{N,T},\n    c::AIMCache{N,T},\n    guess::T;\n    nls_xtol::Real = convert(T, 1.0e-10),\n    nls_ftol::Real = convert(T, 1.0e-10),\n    nls_iterations::Int = 1000\n    ) where {N <: Unsigned, T <: Complex}\n\nCompute a single eigenvalue for the problem p with corresponding cache c.\n\nInput\n\np::NumericAIMProblem: The previously defined problem data.\nc::AIMCache: The cache constructed from p.\nnls_xtol::Real: Norm difference in x between two successive iterates under which convergence is declared.\nnls_ftol::Real: Infinite norm of residuals under which convergence is declared.\nnls_iterations::Int: Maximum number of iterations performed by NLsolve.\n\nOutput\n\nAn object of type SolverResults returned by nlsolve. See NLsolve.jl for further details.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{NumericAIMProblem{N,T},AIMCache{N,T},T}} where T<:Real where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.computeEigenvalues","text":"computeEigenvalues(\n    p::NumericAIMProblem{N,T},\n    c::AIMCache{N,T},\n    guess::T;\n    roots_atol::Real = 1.0e-10,\n    roots_rtol::Real = 1.0e-10,\n    roots_xatol::Real = 1.0e-10,\n    roots_xrtol::Real = 1.0e-10,\n    roots_maxevals::Int = 100,\n    roots_maxfnevals::Int = 100,\n    ) where {N <: Unsigned, T <: Real}\n\nCompute a single eigenvalue for the problem p with corresponding cache c. For details on convergence settings see Roots.jl.\n\nInput\n\np::NumericAIMProblem{N,T}: The previously defined problem data.\nc::AIMCache{N,T}: The cache constructed from p.\ngrid::Tuple{T,T}: A tuple consisting of (start point, end point).\nroots_atol::Real: Absolute tolerance.\nroots_rtol::Real: Relative tolerance.\nroots_xatol::Real: Floating point comparison absolute tolerance.\nroots_xrtol::Real: Floating point comparison relative tolerance.\nroots_maxevals::Int: Number of algorithm iterations performed.\nroots_maxfnevals::Int:Number of function evaluations performed.\n\nOutput\n\nAn object of type T containing the found eigenvalue.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{QuadraticEigenvalueProblem{N,T},AIMCache{N,Polynomials.Polynomial{T}}}} where T<:Number where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.computeEigenvalues","text":"computeEigenvalues(\n    p::QuadraticEigenvalueProblem{N,T},\n    c::AIMCache{N,Polynomial{T}};\n    plr_polish::Bool = true, \n    plr_epsilon::Real = convert(T, 1.0e-10)\n    ) where {N <: Unsigned, T <: Number}\n\nCompute the eigenvalues for the problem p with corresponding cache c.\n\nInput\n\np::QuadraticEigenvalueProblem: The previously defined problem data.\nc::AIMCache: The cache constructed from p.\nplr_polish::Bool: Tell PolynomialRoots to divide the original polynomial by each root found and polish the results using the full polynomial.\nplr_epsilon::Real: The stopping criterion described in Skowron & Gould paper. This is not the precision with which the roots will be calculated.\n\nOutput\n\nAn object of type Array{T,1} containing the computed eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.eigenvaluesInGrid-Union{Tuple{T}, Tuple{N}, Tuple{NumericAIMProblem{N,T},AIMCache{N,T},Tuple{T,T,Int64,Int64}}} where T<:Complex where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.eigenvaluesInGrid","text":"eigenvaluesInGrid(\n    p::NumericAIMProblem{N,T},\n    c::AIMCache{N,T},\n    grid::Tuple{T,T,Int64,Int64};\n    xtol::Real = 1.0e-10,\n    ftol::Real = 1.0e-10,\n    iterations::Int = 1000\n    ) where {N <: Unsigned, T <: Complex}\n\nAttempts to find eigenvalues using a grid of complex plane data points as initial guesses passed to nlsolve.\n\nInput\n\np::NumericAIMProblem{N,T}: The previously defined problem data.\nc::AIMCache{N,T}: The cache constructed from p.\ngrid::Tuple{T,T,Int64,Int64}: A tuple consisting of (start point, end point, num. of real pts., num. of imag. pots.).\nxtol::Real: Norm difference in x between two successive iterates under which convergence is declared.\nftol::Real: Infinite norm of residuals under which convergence is declared.\niterations::Int: Maximum number of iterations performed by NLsolve.\n\nOutput\n\nAn object of type Array{T,1} containing the modes found within the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.eigenvaluesInGrid-Union{Tuple{T}, Tuple{N}, Tuple{NumericAIMProblem{N,T},AIMCache{N,T},Tuple{T,T}}} where T<:Real where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.eigenvaluesInGrid","text":"eigenvaluesInGrid(\n    p::NumericAIMProblem{N,T},\n    c::AIMCache{N,T},\n    grid::Tuple{T,T};\n    roots_atol::Real = 1.0e-10,\n    roots_rtol::Real = 1.0e-10,\n    roots_xatol::Real = 1.0e-10,\n    roots_xrtol::Real = 1.0e-10,\n    roots_maxevals::Int = 100,\n    roots_maxfnevals::Int = 100,\n    ) where {N <: Unsigned, T <: Real}\n\nAttempts to find eigenvalues using a range of real data points as a search region to find_zeros. For details on convergence settings see Roots.jl.\n\nInput\n\np::NumericAIMProblem{N,T}: The previously defined problem data.\nc::AIMCache{N,T}: The cache constructed from p.\ngrid::Tuple{T,T}: A tuple consisting of (start point, end point).\nroots_atol::Real: Absolute tolerance.\nroots_rtol::Real: Relative tolerance.\nroots_xatol::Real: Floating point comparison absolute tolerance.\nroots_xrtol::Real: Floating point comparison relative tolerance.\nroots_maxevals::Int: Number of algorithm iterations performed.\nroots_maxfnevals::Int:Number of function evaluations performed.\n\nOutput\n\nAn object of type Array{T,1} containing the eigenvalues found within the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.get_ODEeigen-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.get_ODEeigen","text":"Analytic problems must implement an acessor to the eigenvalue of the ODE.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.get_ODEvar-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.get_ODEvar","text":"Analytic problems must implement an acessor to the variable of the ODE.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.get_niter-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.get_niter","text":"All problem types must implement get_niter to return the number of iterations to perform.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.get_x0-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.get_x0","text":"All problem types must implement get_x0 to return AIM's point of evaluation.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.λ0-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.λ0","text":"All problem types must implement a λ0 function. This behaviour is enforced by the default implementations.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#Private-types","page":"API Reference","title":"Private types","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPublic = false\nOrder   = [:type]","category":"page"},{"location":"api_ref/#QuasinormalModes.AnalyticityTrait","page":"API Reference","title":"QuasinormalModes.AnalyticityTrait","text":"Super-type of traits describing the analyticity of eigenvalue problems.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.AnalyticityTrait-Tuple{Type{var\"#s13\"} where var\"#s13\"<:AnalyticAIMProblem}","page":"API Reference","title":"QuasinormalModes.AnalyticityTrait","text":"The trait of AnalyticAIMProblem(s).\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.AnalyticityTrait-Tuple{Type{var\"#s13\"} where var\"#s13\"<:NumericAIMProblem}","page":"API Reference","title":"QuasinormalModes.AnalyticityTrait","text":"The trait of NumericAIMProblem(s).\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.AnalyticityTrait-Tuple{Type{var\"#s20\"} where var\"#s20\"<:AIMProblem}","page":"API Reference","title":"QuasinormalModes.AnalyticityTrait","text":"The default trait of AIMProblem(s).\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.IsAnalytic","page":"API Reference","title":"QuasinormalModes.IsAnalytic","text":"All problems with eigenvalues that CAN be described by analytic functions have this trait.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.IsNumeric","page":"API Reference","title":"QuasinormalModes.IsNumeric","text":"All problems with eigenvalues that CAN'T be described by analytic functions have this trait.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#Private-functions","page":"API Reference","title":"Private functions","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPublic = false\nOrder   = [:function]","category":"page"},{"location":"api_ref/#QuasinormalModes.AIMStep!-Union{Tuple{U}, Tuple{T}, Tuple{N}, Tuple{AIMProblem{N,T},AIMCache{N,U}}} where U where T<:Number where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.AIMStep!","text":"AIMStep!(p::AIMProblem{N,T}, c::AIMCache{N,U}) where {N <: Unsigned, T <: Number, U <: Any}\n\nPerforms a single step of the AIM algorithm:\n\nThe initial data arrays are not altered.\nThe previous arrays receive the values of the current arrays.\nThe results of the next step computed using the initial and current arrays. Results are stored in the buffer arrays.\nThe current arrays receive the contents of the buffer arrays.\n\nInput\n\np::AIMProblem: The problem data to use in the computation.\nc::AIMCache: The cache of arrays that corresponds to the problem p.\n\nOutput\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computePolynomialFactors-Union{Tuple{T}, Tuple{N}, Tuple{QuadraticEigenvalueProblem{N,T},N,Function}} where T<:Number where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.computePolynomialFactors","text":"computePolynomialFactors(p::QuadraticEigenvalueProblem{N,T}, n::N, f::Function) where {N <: Unsigned, T <: Number}\n\nCreate a second order Polynomial object in the variable ω by computing derivatives of λ0 or S0.\n\nInput\n\np::QuadraticEigenvalueProblem: The problem data with the expressions to derivate.\nn::Unsigned: The order of the derivative.\nf::Function: the function to extract the polynomial from. Either λ0 or S0.\n\nOutput\n\nAn object of type Polynomial{T} containing the polynomial resulting from the derivation of the expression.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.createPoly-Union{Tuple{T}, Tuple{N}, Tuple{QuadraticEigenvalueProblem{N,T},N,Function}} where T<:Number where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.createPoly","text":"createPoly(p::QuadraticEigenvalueProblem{N,T}, n::N, f::Function)\n\nCompute the n-th coefficient of the Taylor expansion around x0 for the functions λ0 or S0\n\nInput\n\np::QuadraticEigenvalueProblem: The problem data with the expressions to derivate.\nn::Unsigned: The order of the derivative.\nf::Function: the function to extract the polynomial from. Either λ0 or S0.\n\nOutput\n\nAn object of type Polynomial{T} containing the polynomial Taylor coefficient.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.dnx-Union{Tuple{T}, Tuple{N}, Tuple{AnalyticAIMProblem{N,T},N,Function,Function}} where T<:Number where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.dnx","text":"dnx(p::AnalyticAIMProblem{N,T}, n::N, f::Function, v::Function) where {N <: Unsigned, T <: Number}\n\nComputes the n-th derivative of the AIM expressions with respect to ODE's variable. This function is only a thin wrapper around SymEngine's own diff function. It works as a barrier function that produces a type stable Basic result.\n\nInput\n\np::AnalyticAIMProblem: The problem data with the expressions to derivate.\nn::Unsigned: The order of the derivative.\nf::Function: The actual expression to derivate. Either λ0 or S0.\nv::Function: The variable to derivate with. Either getODEvar or getODEeigen.\n\nOutput\n\nA SymEngine.Basic object with the derived expression.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.dnx-Union{Tuple{T}, Tuple{T,SymEngine.Basic,SymEngine.Basic}} where T<:Unsigned","page":"API Reference","title":"QuasinormalModes.dnx","text":"dnx(n::T, f::Basic, v::Basic) where {T <: Unsigned}\n\nComputes the n-th derivative of the the function f with respect to the variable v. This function re implements SymEngine's own diff function using an early quitting strategy.\n\nInput\n\nn::T: The order of the derivative.\nf::Basic: The expression to derivate.\nv::Basic: The variable to derivate with.\n\nOutput\n\nA SymEngine.Basic object with the derived expression.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.recomputeInitials!-Union{Tuple{T}, Tuple{N}, Tuple{NumericAIMProblem{N,T},AIMCache{N,T},T}} where T<:Number where N<:Unsigned","page":"API Reference","title":"QuasinormalModes.recomputeInitials!","text":"recomputeInitials(p::NumericAIMProblem{N,T}, c::AIMCache{N,T}, ω::T) where {N <: Unsigned, T <: Number}\n\nReevaluate (in-place) the initial data arrays. The initial data array elements are the Taylor expansion coefficients of λ0 and S0 in the ODE variable x around x0 of order get_niter(p) at a point ω.\n\nInput\n\np::NumericAIMProblem: The problem data.\nc::AIMCache: The problem data associated cache.\nω::T: The value of the eigenvalue to evaluate the arrays in.\n\nOutput\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"schw/#Complete-Example:-Schwarzschild-Quasinormal-Modes","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"To illustrate how to use QuasinormalModes.jl we will show from start to finish how to compute the quasinormal modes of a Schwarzschild black hole perturbed by an external field. This section will follow closely Emanuele Berti's lectures on black hole perturbation theory, which can be found here and in Ref. [3]","category":"page"},{"location":"schw/#Mathematical-preliminaries","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Mathematical preliminaries","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Let's say that our Schwarzschild black hole is being perturbed by an external field psi_ls where s is the spin of the field (s = 0 1 2 for scalar, electromagnetic and gravitational perturbations, respectively) and l is the angular index of the perturbation. Using mass units such that 2M=1 the \"master\" radial equation governing the perturbation is ","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"r(r-1)psi_ls^primeprime(r) + psi_ls^prime(r) - left l(l+1) - fracs^2-1r - fracomega^2 r^3r-1 rightpsi_ls(r) = 0","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"where primes denote derivatives with respect to the radial coordinate r and omega are the quasinormal frequencies. Since we are solving for quasinormal modes, we need to enforce the proper boundary conditions in the master equation: Classically no wave can escape from the BH's event horizon and at spatial infinity waves can only \"leave\" the space-time. It's thus said that our field is purely ingoing in the event horizon (when rrightarrow 1) and purely outgoing at spatial infinity (when rrightarrowinfty). Mathematically, this means that the solution to the master equation must be of the form","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"psi_ls(r) = (r-1)^-i omega r^2 i omega e^i omega (r-1)f_ls(r)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"By substituting this solution ansatz in the master equation, we obtain a new 2nd order ODE, now for the function f_ls(r). This new ODE is enforcing the correct boundary quasinormal mode boundary conditions. This process usually referred to as incorporating the boundary conditions into the differential equation. The resulting equation reads","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"r left((r-1) r f^primeprime(r)+left(1+2 i left(r^2-2right) omega right) f^prime(r)right)+f(r) left(-r left(l^2+l-4 omega ^2right)+s^2+(2 omega +i)^2right) = 0","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The last step, although not strictly required, facilitates the numerical handling of the equation. Because the radial coordinates extends from the event horizon to infinity, that is, rin 1infty and computers can't handle infinities, we re-scale the ODE's domain to a finite one. This can be easily done with the change of variables","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"x = 1 - frac1r","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"which implies that when r=1 we have x=0 and when rrightarrowinfty we have x = 1. Thus the solution domain has been successfully compactifyied in the interval xin01. By making this change of variables we get to the final form of the master equation which we will actually feed to QuasinormalModes.jl","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"-x (x-1)^2 f^primeprime(x) + (x (4 i (x-2) omega -3 x+4)+2 i omega -1) f^prime(x)+f(x) left(l^2+l+left(s^2-1right) (x-1)+4 (x-2) omega ^2+4 i (x-1) omega right) = 0","category":"page"},{"location":"schw/#Implementing-the-master-equation-as-an-analytic-problem","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Implementing the master equation as an analytic problem","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"In this section we will assume that the user has installed and loaded the SymEngine package. The first step is to create a parametric type that sub-types AnalyticAIMProblem. As the eigenvalue in the master equation is a quadratic polynomial, we will sub-type QuadraticEigenvalueProblem with the following structure:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"struct SchwarzschildData{N,T} <: QuadraticEigenvalueProblem{N,T}\n    nIter::N\n    x0::T\n\n    vars::Tuple{Basic, Basic}\n    exprs::Tuple{Basic, Basic}\nend","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"As the reader might notice the structure is quite simple. The variables nIter and x0 store the AIM's number of iterations and expansion point, respectively while vars will be responsible for storing the SymEngine variables representing the ODE's variable and eigenvalue, respectively, as a tuple. Finally exprs will store the SymEngine expressions for the λ0 and S0 parts of the ODE.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Next we create a parametric constructor for SchwarzschildData that will initializes the fields:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"function SchwarzschildData(nIter::N, x0::T, l::N, s::N) where {N,T}\n    vars = @vars x ω\n\n    λ0 = (-1 + (2*im)*ω + x*(4 - 3*x + (4*im)*(-2 + x)*ω))/((-1 + x)^2*x)\n    S0 = (l + l^2 + (-1 + s^2)*(-1 + x) + (4*im)*(-1 + x)*ω + 4*(-2 + x)*ω^2)/((-1 + x)^2*x)\n\n    return SchwarzschildData{N,T}(nIter, x0, vars, (λ0, S0))\nend","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"This constructor can be used by passing the values directly instead of explicitly declaring type parameters. The final step is to extend the default accessors functions to operate on SchwarzschildData","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"QuasinormalModes.λ0(d::SchwarzschildData{N,T}) where {N,T} = d.exprs[1]\nQuasinormalModes.S0(d::SchwarzschildData{N,T}) where {N,T}  = d.exprs[2]\n\nQuasinormalModes.get_niter(d::SchwarzschildData{N,T}) where {N,T} = d.nIter\nQuasinormalModes.get_x0(d::SchwarzschildData{N,T}) where {N,T} = d.x0\n\nQuasinormalModes.get_ODEvar(d::SchwarzschildData{N,T}) where {N,T} = d.vars[1]\nQuasinormalModes.get_ODEeigen(d::SchwarzschildData{N,T}) where {N,T} = d.vars[2]","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"These functions are fairly straightforward and accessors and require no additional comment.","category":"page"},{"location":"schw/#Implementing-the-master-equation-as-a-numeric-problem","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Implementing the master equation as a numeric problem","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Again we start by defining a structure but this time around we sub-type NumericAIMProblem","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"struct NSchwarzschildData{N,T} <: NumericAIMProblem{N,T}\n    nIter::N\n    x0::T\n    l::N\n    s::N\nend","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Here nIter and x0 have the same meaning as before, but now instead of storing symbolic variables and expressions we store two additional unsigned integers, l and s. These are the angular and spin parameters of the master equation. Here we must store them in the struct as they can't be \"embedded\" into the expressions for λ0 and S0 as in the analytic case.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"We proceeded once again by creating a more convenient constructor. This time no intermediate computation is required upon the construction:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"function NSchwarzschildData(nIter::N, x0::T, l::N, s::N) where {N,T}\n    return NSchwarzschildData{N,T}(nIter, x0, l, s)\nend","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Finally we extend the default implementations","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"QuasinormalModes.λ0(::NSchwarzschildData{N,T}) where {N,T} = (x,ω) -> (-1 + (2*im)*ω + x*(4 - 3*x + (4*im)*(-2 + x)*ω))/((-1 + x)^2*x)\nQuasinormalModes.S0(d::NSchwarzschildData{N,T}) where {N,T} = (x,ω) -> (d.l + d.l^2 + (-1 + d.s^2)*(-1 + x) + (4*im)*(-1 + x)*ω + 4*(-2 + x)*ω^2)/((-1 + x)^2*x)\n\nQuasinormalModes.get_niter(d::NSchwarzschildData{N,T}) where {N,T} = d.nIter\nQuasinormalModes.get_x0(d::NSchwarzschildData{N,T}) where {N,T} = d.x0","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"This time λ0 and S0 return two parameters lambda functions that will be called multiple times during the evaluation of the AIM. As we've previously mentioned, the first parameters is assumed to be the ODE's variables while the second the ODE's eigenvalue. The body of each lambda is the expression for their respective parts on the ODE.","category":"page"},{"location":"schw/#Constructing-problems-and-initializing-the-cache","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Constructing problems and initializing the cache","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"We create our problems and cache objects by calling the constructors:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"p_ana = SchwarzschildData(0x00030, Complex(0.43, 0.0), 0x00000, 0x00000);\np_num = NSchwarzschildData(0x00030, Complex(0.43, 0.0), 0x00000, 0x00000);\n\nc_ana = AIMCache(p_ana)\nc_num = AIMCache(p_num)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Here we are setting up problems to be solved using 48 iterations with x0 = 0.43 + 0.0*im and l = s = 0.","category":"page"},{"location":"schw/#Computing-the-eigenvalues","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Computing the eigenvalues","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"To compute eigenvalues, 3 functions are provided:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"computeDelta!: Compute the AIM \"quantization condition\".\ncomputeEigenvalues: Compute a single, or a list of eigenvalues.\neigenvaluesInGrid: Find all eigenvalues in a certain numerical grid.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Depending on the problem type, these functions return and behave differently. In a QuadraticEigenvalueProblem for instance, computeDelta! returns a polynomial whose roots are the eigenvalues of the ode. In a NumericAIMProblem it returns a value of the quantization condition at a given point, which means that in this case it behaves as a numerical function that can be used with an external root finding algorithm. To see the behaviour of these functions with each problem type I suggest reading the API Reference where specific descriptions can be found. ","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"First, we will call computeEigenvalues(p_ana, c_ana). This returns an array with all the roots of the quantization condition. We will sort the array by descending order in the imaginary part and after that we will filter the array to remove entries whose real part is too small or with a positive imaginary part and print the result to stdout:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"m_ana = computeEigenvalues(p_ana, c_ana)\n\nfunction printQNMs(qnms, cutoff, instab)\n    println(\"-\"^165)\n    println(\"|\", \" \"^36, \"Re(omega)\", \" \"^36, \" \", \" \"^36, \"Im(omega)\", \" \"^36, \"|\")\n    println(\"-\"^165)\n\n    for qnm in qnms\n        if real(qnm) > cutoff && ( instab ? true : imag(qnm) < big\"0.0\" )\n        println(real(qnm), \"    \", imag(qnm))\n        end\n    end\n    \n    println(\"-\"^165)\n\n    return nothing\nend\n\nsort!(m_ana, by = x -> imag(x))\nprintQNMs(m_ana, 1.0e-10, false)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Note that not all values are actually eigenvalues of the ODE (that is, quasinormal modes). This is to be expected and a similar effect is also observed in other numerical methods that perform the same task, such as the pseudo-spectral method. To find \"true\" modes, the user must experiment with the expansion parameter x0, the number of iterations and perform successive convergence tests with the computed modes.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Next we will call","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"ev = computeEigenvalues(p_num, c_num, Complex(0.22, -0.20), nls_xtol = 1.0e-10, nls_ftol = 1.0e-10)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The variable ev now contains a SolverResults object from the NLsolve.jl package. The first solution element represents the real part of the computed mode while the second represents the imaginary part. The object also contains information about the convergence of the method. Note that with a numerical problem we can only find one mode at a time using a certain initial guess. This can be somewhat remedied by using eigenvaluesInGrid, which uses multiple initial conditions as a guess and collects the converged results.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The complete source code of this example can be found in schwarzschild.jl","category":"page"}]
}
