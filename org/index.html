<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Package organization · QuasinormalModes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="QuasinormalModes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">QuasinormalModes.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Table of Contents</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Package organization</a><ul class="internal"><li><a class="tocitem" href="#A-Brief-description-of-the-AIM"><span>A Brief description of the AIM</span></a></li><li><a class="tocitem" href="#The-type-hierarchy"><span>The type hierarchy</span></a></li><li><a class="tocitem" href="#Type-traits"><span>Type traits</span></a></li><li><a class="tocitem" href="#Extending-the-default-functionality"><span>Extending the default functionality</span></a></li><li><a class="tocitem" href="#The-memory-cache"><span>The memory cache</span></a></li></ul></li><li><a class="tocitem" href="../schw/">Complete Example: Schwarzschild Quasinormal Modes</a></li><li><a class="tocitem" href="../sho/">Complete Example: The Harmonic Oscilator</a></li><li><a class="tocitem" href="../api_ref/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Package organization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Package organization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/master/docs/src/org.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Package-organization"><a class="docs-heading-anchor" href="#Package-organization">Package organization</a><a id="Package-organization-1"></a><a class="docs-heading-anchor-permalink" href="#Package-organization" title="Permalink"></a></h1><h2 id="A-Brief-description-of-the-AIM"><a class="docs-heading-anchor" href="#A-Brief-description-of-the-AIM">A Brief description of the AIM</a><a id="A-Brief-description-of-the-AIM-1"></a><a class="docs-heading-anchor-permalink" href="#A-Brief-description-of-the-AIM" title="Permalink"></a></h2><p><code>QuasinormalModes.jl</code> is in it&#39;s core an implementation of the Asymptotic Iteration Method. For a complete description of the general method the reader is encouraged to read <a href="https://arxiv.org/abs/math-ph/0309066v1">this paper</a>. Our implementation is based on the variation of the method described in <a href="https://arxiv.org/abs/1111.5024">this paper</a>. The method requires 3 basic steps:</p><ol><li>Incorporate the asymptotic boundary conditions into the ODE.</li><li>Compactify the domain of the problem (if it isn&#39;t already compact).</li><li>Write the ODE in the form <span>$y^{\prime\prime}(x) = \lambda_0(x)y^{\prime}(x) + s_0(x)y(x)$</span></li></ol><p>From the ODE coefficients <span>$\lambda_0(x)$</span> and <span>$s_0(x)$</span> the AIM computes the eigenvalues by requiring that the &quot;quantization condition&quot;</p><p class="math-container">\[\delta_n = s_n\lambda_{n-1} - s_{n-1}\lambda_{n} = 0\]</p><p>is satisfied, where</p><p class="math-container">\[\lambda_n = \lambda^\prime_{n-1} + s_{n-1} + \lambda_0 \lambda_{n-1}\]</p><p>and</p><p class="math-container">\[s_n = s^\prime_{n-1} + s_0 s_{n-1}.\]</p><p><code>QuasinormalModes.jl</code> expects as input the <span>$\lambda_0(x)$</span> and <span>$s_0(x)$</span> coefficients computed with the 3 steps described above. This documentation contains two practical examples of how to obtain and feed such coefficients to the package.</p><h2 id="The-type-hierarchy"><a class="docs-heading-anchor" href="#The-type-hierarchy">The type hierarchy</a><a id="The-type-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#The-type-hierarchy" title="Permalink"></a></h2><p><code>QuasinormalModes.jl</code> employs two main strategies in order to find eigenvalues using the AIM: problems can be solved in a semi-analytic or purely numeric fashion. We make use of Julia&#39;s type system in order to implement structures that reflect these operation modes. All of the package&#39;s exported functionality is designed to operate on sub-types of abstract types that reflect the desired solution strategy (semi-analytic or numeric). The user is responsible for constructing concrete types that are sub-types of the exported abstract types with the actual problem specific information. It&#39;s thus usefully to start by inspecting the package&#39;s exported type hierarchy:</p><table border="0"><tr>
<td>
	<figure>
		<img src='../assets/types.svg' alt='missing'><br>
		<figcaption><em>QuasinormalModes.jl type hierarchy</em></figcaption>
	</figure>
</td>
</tr></table><ol><li><code>AIMProblem</code> is the parent type of all problems that can be solved with this package. All problems must be sub-type it and a user can use it to construct functions that operate on all AIM solvable problems.</li><li><code>NumericAIMProblem</code> is the parent type of all problems that can be solved using a numeric approach.</li><li><code>AnalyticAIMProlem</code> is the parent type of all problems that can be solved using a semi-analytic approach.</li><li><code>QuadraticEigenvaluePoblem</code> is a specific type of analytic problem whose eigenvalues appear in the ODE as a (possibly incomplete) quadratic polynomial.</li></ol><p>All types are parameterized by two parameters: <code>N &lt;: Unsigned</code> and <code>T &lt;: Number</code> which represent respectively, the type used to represent the number of iterations the AIM will perform and the type used in the numeric computations of the method.</p><h2 id="Type-traits"><a class="docs-heading-anchor" href="#Type-traits">Type traits</a><a id="Type-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Type-traits" title="Permalink"></a></h2><p>Type traits are non-exported abstract types that help the user to ensure that their sub-types implement the correct functions. Currently there is only one defined trait, called <code>AnalyticityTrait</code>. This trait can have two possible &quot;values&quot;: <code>IsAnalytic</code> and <code>IsNumeric</code>, that are represented by concrete types. The default trait of an <code>AIMProblem</code> is <code>IsNumeric</code>, while any sub-type of <code>AnalyticAIMProblem</code> has the <code>IsAnalytic</code> and <code>NumericAIMProblem</code> have the <code>IsNumeric</code> trait</p><p>With these traits, we enforce that the user must implement for all problem types, the following functions:</p><ol><li><code>λ0</code>: Return the λ0 component of the ODE. The actual implementation depends heavily on the problem type.</li><li><code>S0</code>: Return the S0 component of the ODE. The actual implementation depends heavily on the problem type.</li><li><code>get_niter</code>: Return the number of iterations that the AIM will perform.</li><li><code>get_x0</code>: Return the expansion point of the AIM.</li></ol><p>For problems with the <code>IsAnalytic</code> trait, the user must implement the following functions function:</p><ol><li><code>get_ODEvar</code> which returns an object that represents the ODE&#39;s variable.</li><li><code>get_ODEeigen</code> which returns an object that represents the ODE&#39;s eigenvalue.</li></ol><p>Failure to implement these functions returns an error with the appropriate message. Note that these traits only check that such functions are implemented for a certain problem type and not that they follow a particular implementation pattern. The contract on the functions implementations is <em>soft</em> and will be clarified further on. Failure to abide by these soft contracts results in undefined behaviour.</p><h2 id="Extending-the-default-functionality"><a class="docs-heading-anchor" href="#Extending-the-default-functionality">Extending the default functionality</a><a id="Extending-the-default-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-the-default-functionality" title="Permalink"></a></h2><p>The following assumes that the package <code>SymEngine</code> is installed. If a problem type <code>P{N,T}</code> is a sub-type of <code>AnalyticAIMProblem{N,T}</code>, the user must extend the default implementations abiding by the following rules</p><ol><li><code>QuasinormalModes.λ0(p::P{N,T}) where {N,T}</code> must return a <code>SymEngine.Basic</code> object representing the symbolic expression for the <code>λ0</code> part of the ODE.</li><li><code>QuasinormalModes.S0(p::P{N,T}) where {N,T}</code> must return a <code>SymEngine.Basic</code> object representing the symbolic expression for the <code>S0</code> part of the ODE.</li><li><code>QuasinormalModes.get_ODEvar(p::P{N,T}) where {N,T}</code> must return a <code>SymEngine.Basic</code> objects representing the <code>SymEngine</code> variable associated with the ODE&#39;s variable.</li><li><code>QuasinormalModes.get_ODEeigen(p::P{N,T}) where {N,T}</code> must return a <code>SymEngine.Basic</code> objects representing the <code>SymEngine</code> variable associated with the ODE&#39;s eigenvalue.</li></ol><p>If a problem type <code>P{N,T}</code> is a sub-type of <code>NumericAIMProblem{N,T}</code>, the user must extend the default implementations abiding by the following rules</p><ol><li><code>QuasinormalModes.λ0(p::P{N,T}) where {N,T}</code> must return a lambda function of two parameters, the first representing the ODE&#39;s variable and the second representing the ODE&#39;s eigenvalue where the body represents the expression for the <code>λ0</code> part of the ODE.</li><li><code>QuasinormalModes.S0(p::P{N,T}) where {N,T}</code> must return a lambda function of two parameters, the first representing the ODE&#39;s variable and the second representing the ODE&#39;s eigenvalue where the body represents the expression for the <code>S0</code> part of the ODE.</li></ol><p>All problems <code>P{N,T}</code> that are a sub-type of <code>AIMProblem{N,T}</code> must extend the default implementations abiding by the following rules</p><ol><li><code>QuasinormalModes.get_niter(p::P{N,T}) where {N,T}</code> must return an unsigned number of type <code>N</code> representing the number of iterations for the AIM to perform.</li><li><code>QuasinormalModes.get_x0(p::P{N,T}) where {N,T}</code> must return a number of type <code>T</code> representing the evaluation point of the AIM.</li></ol><p>In the following sections, concrete examples of problems will be illustrated in order to better acquaint the user with the package and hopefully clear out any remaining misunderstandings.</p><div class="admonition is-info"><header class="admonition-header">Semi-analytic VS numeric approach</header><div class="admonition-body"><p>Because of the semi-analytic nature of the operation performed when a structure is a subtype of <code>AnalyticAIMProblem</code>, <code>QuasinormalModes.jl</code> is naturally slower to compute modes in this case. One may also find that for a large number of iterations the AIM might even fail to find modes. A general good approach would be to use the semi-analytic mode to generate lists of eigenvalues for a number of iterations that runs reasonably fast and then use these results as initial guesses for the numeric mode with a high number of iterations.</p></div></div><h2 id="The-memory-cache"><a class="docs-heading-anchor" href="#The-memory-cache">The memory cache</a><a id="The-memory-cache-1"></a><a class="docs-heading-anchor-permalink" href="#The-memory-cache" title="Permalink"></a></h2><p>In order to minimize memory allocations, all functions that actually compute eigenvalues require a <code>AIMCache</code> object. Given a certain a problem <code>P{N,T}</code> it initializes memory for 8 arrays of size <code>get_niter(p) + one(N)</code> elements of type <code>T</code>. These arrays are used to store intermediate and final computation results. By using a cache object, we guarantee that memory for the computation data is allocated only once and not at each step of the AIM.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><a class="docs-footer-nextpage" href="../schw/">Complete Example: Schwarzschild Quasinormal Modes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 11 January 2021 23:26">Monday 11 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
